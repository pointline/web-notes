# 接口
TypeScript的核心原则之一是对值所具有的结构进行检查

> 接口名首字母大写

## 接口初探
下面一个例子：

```javascript {1-4}
interface Person {
  name: string;
  age: number;
}

function printPerson(person: Person) {
  console.log(person);
}

let peter = { name: "peter", age: 10 };
printPerson(peter);
```

`Person`接口就好比一个名字，用来描述printPerson函数参数person的结构

## 可选属性
接口里的属性不全都是必须的。有些是只在某些条件下存在，或者根本不存在。可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值

```javascript
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  const newSquare = { color: "white", area: 100 };
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({ color: "black" });
```

> 带有可选属性的接口与普通接口定义差不多，只是在可选属性名字定义的后面加一个`?`符号

## 只读属性
一些对象属性只能在对象刚刚创建的时候修改其值。

> 在属性名前面用`readonly`来指定只读属性

```javascript
interface RoConfig {
  readonly cpu: number;
  readonly memory: string;
}

let phoneConfig: RoConfig = {
  cpu: 2,
  memory: "8G"
};

// 修改会报错，是只读属性
// phoneConfig.memory = "4G"; // error
```

TypeScript具有`ReadonlyArray<T>`类型，它与`Array<T>`相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改

```javascript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

上面代码的最后一行，可以看到就算把整个`ReadonlyArray`赋值到一个普通数组也是不可以的。但是你可以用类型断言重写：

```javascript
a = ro as number[];
```

## readonly vs const
最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用`const`，若做为属性则使用`readonly`

## 额外的检查
比如我们上面的例子可选属性，部分属性是可传可不传的。那么额外属性就是在接口定义的基础上多传入一些属性

多传colour属性给createSquare。TypeScript会认为这段代码可能存在bug。对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何“目标类型”不包含的属性时，会得到一个错误

下面的例子：

```javascript
// error: 'colour' not expected in type 'SquareConfig'
let mySquare = createSquare({ colour: "red", width: 100 });
```

绕开这些检查非常简单。最简便的方法是使用类型断言

```javascript
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

> 最佳的方式是能够添加一个`字符串索引签名`

前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。如果SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它

```javascript
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么

还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量：因为squareOptions不会经过额外属性检查，所以编译器不会报错

```javascript
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```

上面的方法只在squareOptions和SquareConfig之间有共同的属性时才好用，也不推荐这样使用
